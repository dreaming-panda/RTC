<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Manual Start Pipeline</title>
    <style>
      body { font-family: sans-serif; }
      video { width: 900px; background: #000; display:block; }
      button { margin-right: 8px; margin-top: 10px; }
      pre { background:#111; color:#0f0; padding:10px; margin-top:10px; height:260px; overflow:auto; }
      .metric { font-size: 14px; padding: 6px 10px; background:#eee; display:inline-block; border-radius: 6px; margin: 6px 8px 0 0; }
      .row { margin-top: 10px; }
      .small { font-size: 12px; opacity: 0.85; }
      .hl { background:#dff7df; }
      .warn { background:#ffe3e3; }
    </style>
  </head>

  <body>
    <h3>Browser connects first, user clicks Start to begin producing frames</h3>

    <video id="v" autoplay playsinline muted></video>

    <div class="row">
      <button id="startBtn" disabled>Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <span class="metric" id="state">state: --</span>
      <span class="metric" id="viewers">viewers: --</span>
    </div>

    <div class="row">
      <button id="actionBtn" disabled>Send Action</button>
      <input id="actionText" value="hit" style="width:220px;margin-left:8px;" />
      <span class="metric small" id="hint">未 Start 时 action 会被 reject</span>
    </div>

    <div class="row">
      <span class="metric" id="ack">ACK RTT: -- ms</span>
      <span class="metric" id="s">InferStart: -- ms</span>
      <span class="metric" id="e">InferEnd: -- ms</span>
      <span class="metric hl" id="vlat">Visible: -- ms</span>
      <span class="metric" id="last">Last: --</span>
    </div>

    <div class="row">
      <span class="metric" id="q">frame_q: --</span>
      <span class="metric" id="inf">infer_id/idx: --</span>
      <span class="metric" id="send">send_fps: --</span>
      <span class="metric" id="infer">infer_fps: --</span>
      <span class="metric" id="eq">est_queue: -- ms</span>
      <span class="metric" id="im">last_infer_ms: --</span>
      <span class="metric hl" id="qb">q_before/q_after: --/--</span>
    </div>

    <pre id="log"></pre>

    <script>
      const video = document.getElementById("v");
      const logEl = document.getElementById("log");

      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const actionBtn = document.getElementById("actionBtn");
      const actionInput = document.getElementById("actionText");

      const stateEl = document.getElementById("state");
      const viewersEl = document.getElementById("viewers");

      const ackEl = document.getElementById("ack");
      const sEl = document.getElementById("s");
      const eEl = document.getElementById("e");
      const vEl = document.getElementById("vlat");
      const lastEl = document.getElementById("last");

      const qEl = document.getElementById("q");
      const infEl = document.getElementById("inf");
      const sendEl = document.getElementById("send");
      const inferEl = document.getElementById("infer");
      const eqEl = document.getElementById("eq");
      const imEl = document.getElementById("im");
      const qbEl = document.getElementById("qb");

      function log(...args) {
        const s = args.map(x => (typeof x === "string" ? x : JSON.stringify(x))).join(" ");
        logEl.textContent += s + "\n";
        logEl.scrollTop = logEl.scrollHeight;
        console.log(...args);
      }

      function setButtons(connected, running) {
        startBtn.disabled = !connected || running;
        stopBtn.disabled = !connected || !running;
        actionBtn.disabled = !connected || !running;
      }

      async function waitIceComplete(pc, timeoutMs = 8000) {
        if (pc.iceGatheringState === "complete") return;
        await new Promise((resolve, reject) => {
          const timer = setTimeout(() => {
            pc.removeEventListener("icegatheringstatechange", onChange);
            reject(new Error("ICE gathering timeout"));
          }, timeoutMs);
          function onChange() {
            if (pc.iceGatheringState === "complete") {
              clearTimeout(timer);
              pc.removeEventListener("icegatheringstatechange", onChange);
              resolve();
            }
          }
          pc.addEventListener("icegatheringstatechange", onChange);
        });
      }

      function newId() {
        return (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()) + "-" + Math.random());
      }

      let pc = null;
      let dc = null;
      let connected = false;
      let running = false;

      const sent = new Map(); // actionId -> {t_click}

      function waitNextRenderFor(id) {
        if (!("requestVideoFrameCallback" in HTMLVideoElement.prototype)) {
          setTimeout(() => {
            const rec = sent.get(id);
            if (!rec) return;
            const dt = performance.now() - rec.t_click;
            vEl.textContent = `Visible: ${dt.toFixed(1)} ms`;
            lastEl.textContent = `Last: visible(fallback) id=${id.slice(0,8)}`;
          }, 34);
          return;
        }
        video.requestVideoFrameCallback((_now, meta) => {
          const rec = sent.get(id);
          if (!rec) return;
          const dt = performance.now() - rec.t_click;
          vEl.textContent = `Visible: ${dt.toFixed(1)} ms`;
          lastEl.textContent = `Last: visible id=${id.slice(0,8)} presentedFrames=${meta.presentedFrames}`;
          log("VISIBLE", id, dt.toFixed(1), "ms");
        });
      }

      async function startWebRTC() {
        setButtons(false, false);

        pc = new RTCPeerConnection({
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
          ]
        });

        pc.ontrack = (evt) => { video.srcObject = evt.streams[0]; };
        pc.onconnectionstatechange = () => log("connectionState:", pc.connectionState);
        pc.oniceconnectionstatechange = () => log("iceConnectionState:", pc.iceConnectionState);

        pc.addTransceiver("video", { direction: "recvonly" });

        dc = pc.createDataChannel("control");

        dc.onopen = () => {
          connected = true;
          setButtons(true, running);
          log("DataChannel open");
        };

        dc.onclose = () => {
          connected = false;
          running = false;
          setButtons(false, false);
          log("DataChannel closed");
        };

        dc.onmessage = (e) => {
          let msg;
          try { msg = JSON.parse(e.data); } catch { return; }

          if (msg.type === "pipeline_state") {
            running = !!msg.running;
            stateEl.textContent = `state: ${running ? "RUNNING" : "IDLE"}`;
            viewersEl.textContent = `viewers: ${msg.viewer_count}`;
            setButtons(connected, running);
            return;
          }

          if (msg.type === "start_ack") {
            running = true;
            stateEl.textContent = "state: RUNNING";
            setButtons(connected, running);
            log("START_ACK", msg);
            return;
          }

          if (msg.type === "stop_ack") {
            running = false;
            stateEl.textContent = "state: IDLE";
            setButtons(connected, running);
            log("STOP_ACK", msg);
            return;
          }

          if (msg.type === "reject") {
            log("REJECT:", msg.reason);
            return;
          }

          if (msg.type === "stats") {
            running = !!msg.running;
            stateEl.textContent = `state: ${running ? "RUNNING" : "IDLE"}`;
            viewersEl.textContent = `viewers: ${msg.viewer_count}`;

            qEl.textContent = `frame_q: ${msg.frame_q} (target=${msg.target_q})`;
            infEl.textContent = `infer_id/idx: ${msg.infer_id}/${msg.frame_index}`;

            sendEl.textContent = `send_fps: ${msg.send_fps} (base=${msg.send_base_fps}, range=${msg.send_range[0]}-${msg.send_range[1]})`;
            inferEl.textContent = `infer_fps: ${msg.infer_fps} (base=${msg.infer_base_fps}, range=${msg.infer_range[0]}-${msg.infer_range[1]})`;

            eqEl.textContent = `est_queue: ${msg.est_queue_ms} ms`;
            imEl.textContent = `last_infer_ms: ${msg.last_infer_ms}`;
            qbEl.textContent = `q_before/q_after: ${msg.last_q_before}/${msg.last_q_after}`;

            setButtons(connected, running);
            return;
          }

          if (msg.type === "infer_stats") {
            qbEl.textContent = `q_before/q_after: ${msg.q_before}/${msg.q_after}`;
            return;
          }

          // per-action RTT
          const id = msg.id;
          if (id && sent.has(id)) {
            const rec = sent.get(id);
            const dt = performance.now() - rec.t_click;

            if (msg.type === "ack") {
              ackEl.textContent = `ACK RTT: ${dt.toFixed(1)} ms`;
              lastEl.textContent = `Last: ack id=${id.slice(0,8)}`;
              return;
            }
            if (msg.type === "infer_start") {
              sEl.textContent = `InferStart: ${dt.toFixed(1)} ms`;
              lastEl.textContent = `Last: infer_start id=${id.slice(0,8)} infer=${msg.infer_id}`;
              return;
            }
            if (msg.type === "infer_end") {
              eEl.textContent = `InferEnd: ${dt.toFixed(1)} ms (infer_ms=${msg.infer_ms})`;
              lastEl.textContent = `Last: infer_end id=${id.slice(0,8)} infer=${msg.infer_id}`;
              return;
            }
            if (msg.type === "applied") {
              lastEl.textContent = `Last: applied id=${id.slice(0,8)} infer=${msg.infer_id}`;
              waitNextRenderFor(id);
              return;
            }
          }
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        try { await waitIceComplete(pc, 8000); } catch {}

        const resp = await fetch("/offer", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sdp: pc.localDescription.sdp, type: pc.localDescription.type })
        });

        const answer = await resp.json();
        await pc.setRemoteDescription(answer);

        log("WebRTC negotiation done");
      }

      startBtn.onclick = () => {
        if (!dc || dc.readyState !== "open") return;
        dc.send(JSON.stringify({ cmd: "start", t_send_ms: Date.now() }));
        log("SEND start");
      };

      stopBtn.onclick = () => {
        if (!dc || dc.readyState !== "open") return;
        dc.send(JSON.stringify({ cmd: "stop", t_send_ms: Date.now() }));
        log("SEND stop");
      };

      actionBtn.onclick = () => {
        if (!dc || dc.readyState !== "open") return;
        if (!running) return;

        const action = actionInput.value || "hit";
        const id = newId();
        sent.set(id, { t_click: performance.now(), action });
        dc.send(JSON.stringify({ cmd: "action", id, action, t_send_ms: Date.now() }));
        lastEl.textContent = `Last: sent id=${id.slice(0,8)} action=${action}`;
      };

      startWebRTC().catch(err => log("start error:", String(err)));
    </script>
  </body>
</html>
